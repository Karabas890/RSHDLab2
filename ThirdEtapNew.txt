# 1. Создаём новое табличное пространство
mkdir -p $HOME/twv39

# Подключаемся к psql как суперпользователь
psql -p 9426 -U postgres2 -d postgres

-- Создаём tablespace в /var/db/postgres2/twv39 (путь должен быть абсолютным и доступен PostgreSQL серверу)
CREATE TABLESPACE twv39 LOCATION '/var/db/postgres2/twv39';
#Подключаемся к другой базе (например, template1), т.к. нельзя удалить базу, к которой мы подключёны
psql -p 9426 -U postgres2 -d template1
-- Отключаем подключения к базе postgres (чтобы можно было её пересоздать)
SELECT pid, usename, application_name, client_addr
FROM pg_stat_activity
WHERE datname = 'postgres';
-- сюда всталвяем свой pid
SELECT pg_terminate_backend(<pid>);
-- Удаляем старую базу postgres
DROP DATABASE postgres;
-- Создаём новую базу postgres на основе template0 в tablespace twv39
CREATE DATABASE postgres
  TEMPLATE template0
  TABLESPACE twv39;

#Проверка
psql -p 9426 -U postgres2 -d postgres
--Проверяем, что она использует нужное табличное пространство:
SELECT datname, pg_tablespace.spcname AS tablespace
FROM pg_database
JOIN pg_tablespace ON pg_database.dattablespace = pg_tablespace.oid
WHERE datname = 'postgres';




# Подключаемся к psql как суперпользователь
psql -p 9426 -U postgres2 -d postgres

-- Создаём новую базу lazywhitewood на основе template1
CREATE DATABASE lazywhitewood
  WITH TEMPLATE = template1
  OWNER = postgres2;

-- Создаём новую роль new_role с паролем и правами подключения
CREATE ROLE new_role LOGIN PASSWORD 'new';

-- Даем роли права подключаться к обеим базам
GRANT CONNECT ON DATABASE postgres TO new_role;
GRANT CONNECT ON DATABASE lazywhitewood TO new_role;

-- Разрешаем роли создавать объекты в tablespace twv39 (если нужно)
GRANT CREATE ON TABLESPACE twv39 TO new_role;
-- Создать таблицу в таблицпространстве postgres
CREATE TABLE test_table_postgres (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    value INTEGER
) TABLESPACE twv39;

-- Дать права на вставку и использование sequence роли new_role
GRANT INSERT, SELECT, UPDATE, DELETE ON test_table_postgres TO new_role;
GRANT USAGE, SELECT ON SEQUENCE test_table_postgres_id_seq TO new_role;

-- Подключиться к базе postgres
psql -h localhost  -p 9426 -U new_role -d postgres
INSERT INTO test_table_postgres (name, value) VALUES
  ('A', 1),
  ('B', 2),
  ('C', 3);
--проверка
SELECT * FROM test_table_lw;

-- Подключиться к базе lazywhitewood (под postgres2)
psql -p 9426 -U postgres2 -d lazywhitewood

-- Создать таблицу в таблицпространстве twv39
CREATE TABLE test_table_lw1 (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  value INTEGER
) TABLESPACE twv39;
-- Создать таблицу в таблицпространстве twv39
CREATE TABLE test_table_lw2 (
  id SERIAL PRIMARY KEY,
  name TEXT NOT NULL,
  value INTEGER
) TABLESPACE twv39;

-- Дать права на вставку и использование sequence роли new_role
GRANT INSERT, SELECT, UPDATE, DELETE ON test_table_lw1 TO new_role;
GRANT USAGE, SELECT ON SEQUENCE test_table_lw1_id_seq TO new_role;
GRANT INSERT, SELECT, UPDATE, DELETE ON test_table_lw2 TO new_role;
GRANT USAGE, SELECT ON SEQUENCE test_table_lw2_id_seq TO new_role;

-- Вставляем
psql -h localhost -p 9426 -U new_role -d lazywhitewood
INSERT INTO test_table_lw1 (name, value) VALUES
  ('X', 10),
  ('Y', 20),
  ('Z', 30);
--проверка
SELECT * FROM test_table_lw1;
INSERT INTO test_table_lw2 (name, value) VALUES
  ('J', 100),
  ('K', 200),
  ('L', 300);
--проверка
SELECT * FROM test_table_lw2;



--Выведем список всех табличных пространств кластера и содержащиеся в них объекты
SELECT
  CASE WHEN ROW_NUMBER() OVER (PARTITION BY COALESCE(t.spcname,
'pg_default') ORDER BY c.relname) = 1
       THEN COALESCE(t.spcname, 'pg_default')
       ELSE NULL
  END AS spcname,
  c.relname
FROM pg_tablespace t
FULL JOIN pg_class c ON c.reltablespace = t.oid
ORDER BY COALESCE(t.spcname, 'pg_default'), c.relname;


